-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.Mutation exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.InputObject
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode exposing (Decoder)


type alias DeleteProjectsRequiredArguments =
    { where_ : Hasura.InputObject.Projects_bool_exp }


{-| delete data from the table: "Projects"

  - where\_ - filter the rows which have to be deleted

-}
delete_Projects :
    DeleteProjectsRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Projects_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_Projects requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_Projects" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeProjects_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteProjectsByPkRequiredArguments =
    { id : Int }


{-| delete single row from the table: "Projects"
-}
delete_Projects_by_pk :
    DeleteProjectsByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Projects
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_Projects_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_Projects_by_pk" [ Argument.required "id" requiredArgs____.id Encode.int ] object____ (Basics.identity >> Decode.nullable)


type alias InsertProjectsOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Projects_on_conflict }


type alias InsertProjectsRequiredArguments =
    { objects : List Hasura.InputObject.Projects_insert_input }


{-| insert data into the table: "Projects"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_Projects :
    (InsertProjectsOptionalArguments -> InsertProjectsOptionalArguments)
    -> InsertProjectsRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Projects_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_Projects fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeProjects_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_Projects" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeProjects_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertProjectsOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Projects_on_conflict }


type alias InsertProjectsOneRequiredArguments =
    { object : Hasura.InputObject.Projects_insert_input }


{-| insert a single row into the table: "Projects"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_Projects_one :
    (InsertProjectsOneOptionalArguments -> InsertProjectsOneOptionalArguments)
    -> InsertProjectsOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Projects
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_Projects_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeProjects_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_Projects_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeProjects_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProjectsOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Projects_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Projects_set_input
    }


type alias UpdateProjectsRequiredArguments =
    { where_ : Hasura.InputObject.Projects_bool_exp }


{-| update data of the table: "Projects"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_Projects :
    (UpdateProjectsOptionalArguments -> UpdateProjectsOptionalArguments)
    -> UpdateProjectsRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Projects_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_Projects fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Hasura.InputObject.encodeProjects_inc_input, Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeProjects_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_Projects" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeProjects_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProjectsByPkOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Projects_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Projects_set_input
    }


type alias UpdateProjectsByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.Projects_pk_columns_input }


{-| update single row of the table: "Projects"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_Projects_by_pk :
    (UpdateProjectsByPkOptionalArguments -> UpdateProjectsByPkOptionalArguments)
    -> UpdateProjectsByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Projects
    -> SelectionSet (Maybe decodesTo) RootMutation
update_Projects_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Hasura.InputObject.encodeProjects_inc_input, Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeProjects_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_Projects_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeProjects_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateProjectsManyRequiredArguments =
    { updates : List Hasura.InputObject.Projects_updates }


{-| update multiples rows of table: "Projects"

  - updates - updates to execute, in order

-}
update_Projects_many :
    UpdateProjectsManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Projects_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_Projects_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_Projects_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeProjects_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)
